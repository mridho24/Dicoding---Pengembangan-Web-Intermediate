/* eslint-disable no-restricted-globals */
import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute, NavigationRoute } from 'workbox-routing';
import { NetworkFirst, StaleWhileRevalidate, CacheFirst } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';

// Precache all assets generated by vite-plugin-pwa
precacheAndRoute(self.__WB_MANIFEST);

// Handle navigation requests with NetworkFirst strategy
const navigationHandler = new NetworkFirst({
  cacheName: 'navigations',
  plugins: [
    new CacheableResponsePlugin({
      statuses: [0, 200],
    }),
  ],
});

// Register navigation route
registerRoute(new NavigationRoute(navigationHandler));

// Cache API requests with better offline handling
registerRoute(
  ({ url }) => url.origin === 'https://story-api.dicoding.dev' && url.pathname.startsWith('/v1/stories'),
  new NetworkFirst({
    cacheName: 'api-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200]
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 24 * 60 * 60 // 24 hours
      })
    ],
    networkTimeoutSeconds: 5
  })
);

// Cache story images with fallback
registerRoute(
  ({ url }) => url.origin === 'https://story-api.dicoding.dev' && url.pathname.includes('/images/'),
  new StaleWhileRevalidate({
    cacheName: 'story-images',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200]
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 7 * 24 * 60 * 60 // 7 days
      })
    ]
  })
);

// Cache map tiles
registerRoute(
  ({ url }) => url.hostname.includes('basemaps.cartocdn.com'),
  new CacheFirst({
    cacheName: 'map-tiles',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 1000,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// Cache Leaflet assets
registerRoute(
  ({ url }) => url.hostname.includes('cdnjs.cloudflare.com') && url.pathname.includes('leaflet'),
  new CacheFirst({
    cacheName: 'leaflet-assets',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// Separate route for font files
registerRoute(
  ({ request }) => request.destination === 'font',
  new CacheFirst({
    cacheName: 'fonts-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// Cache other static assets (JS, CSS, images)
registerRoute(
  ({ request }) =>
    request.destination === 'style' ||
    request.destination === 'script' ||
    request.destination === 'image',
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 24 * 60 * 60, // 24 hours
      }),
    ],
  })
);

// Improved offline fallback with better error handling
self.addEventListener('fetch', (event) => {
  if (event.request.mode === 'navigate') {
    event.respondWith(
      (async () => {
        try {
          // First, try the network
          const networkResponse = await fetch(event.request);
          if (networkResponse.ok) {
            const cache = await caches.open('navigations');
            await cache.put(event.request, networkResponse.clone());
            return networkResponse;
          }
          throw new Error('Network response was not ok');
        } catch (error) {
          console.log('Fetch failed; returning offline page instead.', error);

          // Try to get the cached response
          const cache = await caches.open('navigations');
          const cachedResponse = await cache.match(event.request);
          if (cachedResponse) {
            return cachedResponse;
          }

          // If no cached response, return cached index.html
          const indexResponse = await cache.match('index.html');
          if (indexResponse) {
            return indexResponse;
          }

          // If everything fails, return a custom offline response
          return new Response('Offline - No cached content available', {
            status: 503,
            statusText: 'Service Unavailable',
            headers: new Headers({
              'Content-Type': 'text/plain',
            }),
          });
        }
      })()
    );
  }

  // Handle image requests with fallback
  if (event.request.destination === 'image') {
    event.respondWith(
      (async () => {
        try {
          // Try to get from cache first
          const cache = await caches.open('story-images');
          const cachedResponse = await cache.match(event.request);
          if (cachedResponse) {
            return cachedResponse;
          }

          // If not in cache, try network
          const networkResponse = await fetch(event.request);
          if (networkResponse.ok) {
            await cache.put(event.request, networkResponse.clone());
            return networkResponse;
          }
          throw new Error('Network response was not ok');
        } catch (error) {
          console.log('Image fetch failed, returning placeholder:', error);
          // Return a placeholder image or fallback response
          return new Response(
            '<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 200 200"><rect width="200" height="200" fill="#ddd"/><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" font-family="sans-serif">Image Unavailable</text></svg>',
            {
              status: 200,
              headers: new Headers({
                'Content-Type': 'image/svg+xml',
              }),
            }
          );
        }
      })()
    );
  }
});

// Handle push notifications
self.addEventListener('push', (event) => {
  let notificationData = {};

  try {
    if (event.data) {
      try {
        notificationData = event.data.json();
      } catch (e) {
        const text = event.data.text();
        notificationData = {
          title: 'Cerita Baru!',
          options: {
            body: text,
            icon: '/favicon.png',
            badge: '/favicon.png',
            vibrate: [200, 100, 200],
            tag: 'ceritakita-notification',
          },
        };
      }
    }
  } catch (error) {
    console.error('Error handling push data:', error);
    notificationData = {
      title: 'Cerita Baru!',
      options: {
        body: 'Ada cerita baru untuk Anda!',
        icon: '/favicon.png',
        badge: '/favicon.png',
        vibrate: [200, 100, 200],
        tag: 'ceritakita-notification',
      },
    };
  }

  const title = notificationData.title || 'Cerita Kita';
  const options = {
    ...notificationData.options,
    icon: '/favicon.png',
    badge: '/favicon.png',
    data: {
      url: notificationData.url || '/',
    },
    requireInteraction: true,
    renotify: true,
    tag: 'ceritakita-notification',
    actions: [
      {
        action: 'view',
        title: 'Lihat Cerita',
      },
      {
        action: 'close',
        title: 'Tutup',
      },
    ],
  };

  event.waitUntil(
    self.registration.showNotification(title, options)
  );
});

// Handle notification click
self.addEventListener('notificationclick', (event) => {
  event.notification.close();

  let urlToOpen = new URL(event.notification.data?.url || '/', self.location.origin).href;

  if (event.action === 'view') {
    if (!urlToOpen.includes('/detail')) {
      urlToOpen = `${self.location.origin}/detail`;
    }
  }

  event.waitUntil(
    clients.matchAll({ type: 'window', includeUncontrolled: true })
      .then((clientList) => {
        for (const client of clientList) {
          if (client.url === urlToOpen && 'focus' in client) {
            return client.focus();
          }
        }
        if (clients.openWindow) {
          return clients.openWindow(urlToOpen);
        }
      })
      .catch(error => {
        console.error('Error handling notification click:', error);
      })
  );
});

// Clean up old caches when a new service worker takes over
self.addEventListener('activate', (event) => {
  event.waitUntil(
    Promise.all([
      self.clients.claim(),
      caches.keys().then(cacheNames => {
        return Promise.all(
          cacheNames.map(cacheName => {
            if (!cacheName.startsWith('workbox-') && !cacheName.endsWith('-cache')) {
              return caches.delete(cacheName);
            }
            return null;
          })
        );
      })
    ])
  );
});
